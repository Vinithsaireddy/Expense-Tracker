import express, { Request, RequestHandler, Response } from 'express';
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import cors from 'cors';
import dotenv from 'dotenv';
dotenv.config();

const app = express();
const PORT = 5000;
const JWT_SECRET = process.env.JWT_SECRET || 'fallback_secret';

app.use(cors());
app.use(express.json());

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/myapp')
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('MongoDB connection error:', err));

// Define User Interface
interface IUser extends Document {
  email: string;
  password: string;
}

// Define Schema and Model
const userSchema = new Schema<IUser>({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

const User = mongoose.model<IUser>('User', userSchema);

// Define request body types
interface AuthRequestBody {
  email: string;
  password: string;
}

// Register Route
const registerHandler: RequestHandler<{}, any, AuthRequestBody> = async (req, res): Promise<void> => {
  try {
    const { email, password } = req.body;

    // Check if the email already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      res.status(400).send('Email already in use');
      return;
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = new User({ email, password: hashedPassword });
    await user.save();
    
    res.status(201).send('User registered');
  } catch (error) {
    console.error('Error registering user:', error);
    
    if ((error as any).code === 11000) { 
      res.status(400).send('Email already in use');
      return;
    }

    res.status(500).send((error as Error).message || 'Error registering user');
  }
};

app.post('/register', registerHandler);

// Login Route
const loginHandler: RequestHandler<{}, any, AuthRequestBody> = async (req, res): Promise<void> => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user || !(await bcrypt.compare(password, user.password))) {
      res.status(401).send('Invalid credentials');
      return;
    }

    const token = jwt.sign({ userId: user._id }, JWT_SECRET);
    res.json({ token });
  } catch (error) {
    console.error('Error logging in:', error);
    res.status(500).send((error as Error).message || 'Error logging in');
  }
};

app.post('/login', loginHandler);

// Define Entry Schema
const entrySchema = new mongoose.Schema({
  type: { type: String, required: true },
  amount: { type: Number, required: true },
  note: { type: String, required: true },
  date: { type: String, required: true },
});

const Entry = mongoose.model("Entry", entrySchema);

// Add Entry API
const addEntryHandler: RequestHandler = async (req, res): Promise<void> => {
  try {
    const { type, amount, note, date } = req.body;
    const newEntry = new Entry({ type, amount, note, date });
    await newEntry.save();
    res.status(201).send("Entry added successfully");
  } catch (error) {
    console.error('Error adding entry:', error);
    res.status(500).send((error as Error).message || "Error adding entry");
  }
};

app.post("/add-entry", addEntryHandler);

// Get History API
const getHistoryHandler: RequestHandler = async (_req, res): Promise<void> => {
  try {
    const history = await Entry.find();
    res.json(history);
  } catch (error) {
    console.error('Error retrieving history:', error);
    res.status(500).send((error as Error).message || "Error retrieving history");
  }
};

app.get("/history", getHistoryHandler);

// Start the Server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
